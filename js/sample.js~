
//In short:
<<<<<<< HEAD

//Sample code 1:

db = eurostatDb();
db.initTable("demo_pjan", {FREQ: "A", AGE: "TOTAL"}, {startYear: 1995, endYear: 2015}, function () {//1
    db.fetchRst("demo_pjan", {SEX: "T", GEO: "NL", OBS_VALUE: {gt: 16e6}}, function (error, rst) {//2

        $("div#info").append("<h2>Total population in the Netherlands (years with >16 million):</h2>");
        if (error) {$("div#info").append("<p>Error: " + error.message + "</p>");return;}
        rst.forEach(function (r) {$("div#info").append("<p>In " + r.TIME + ": " + r.OBS_VALUE + "</p>");}); //3
    });
});
//What's happening here?
//1: specifies the name of the dataflow that I'm interested in, and fixes some of its dimensions and the time period. That way, I always fetch annual data and age aggregates, from the time period between 1995 and 2015.
//2: fetches data for total population of Netherlands above 16million.
//3: then uses this data to make a list.


//sample code 2: no prior knowledge

cb = function (error, data) { //callback to display information to console
    if (error) console.error(error.message);
    else console.log(JSON.stringify(data));
};
function step1() {db.fetchDfs("monthly", cb );}
function step2() {db.fetchDsd("DS-008573", cb);}
function step3() {db.initTable("DS-008573", cb);}
function step4() {db.fetchData("DS-008573", {FREQ:"M", DECLARANT:["001", "003"], PRCCODE:["27101100", "27101250"], MEASUREMENT_UNIT:"VALUE", INDICATORS: "IMPORTS"}, cb);}
function step5() {db.fetchRst("DS-008573", {FREQ:"M", DECLARANT:["001", "003"], PRCCODE:["27101100", "27101250"], MEASUREMENT_UNIT:"VALUE", INDICATORS: "IMPORTS"}, cb);}





//Sample code 3:
//TODO: needs work (joins not satisfactorily solved)

function sample3(){
    db.initTable("demo_pjan", {FREQ: "A", AGE: "TOTAL"}, {startYear: 1995, endYear: 2015}, function () {//1
        db.fetchData("demo_pjan", {SEX: ["M", "F"], GEO:"NL"}, function() {
            var rstM = db.getRst("demo_pjan", {SEX: ["M"], GEO:"NL"}, "TIME asec"),
                rstF = db.getRst("demo_pjan", {SEX: ["F"], GEO:"NL"}, "TIME asec"),
                rst = [];
            for (var i = 0; i<rstM.length; i++) {
                var r = {TIME: rstM[i].TIME, OBS_VALUE: rstM[i].OBS_VALUE/(rstM[i].OBS_VALUE+rstF[i].OBS_VALUE)};
                rst.push(r);
            }
            $("div#info").append("<h2>Male percentage in the Netherlands:</h2>");
            rst.forEach(function(r) {$("div#info").append("<p>In " + r.TIME + ": " + r.OBS_VALUE + "</p>");}); //4
        });
    });
}
=======
db = eurostatDb();
db.addTable("demo_pjan", {FREQ: "A", AGE: "TOTAL"}, {startYear: 2000, endYear: 2015}, function () {//1
    db.fetchData("demo_pjan", {SEX:["T", "M", "F"], GEO:["FR", "NL", "BE", "LU"]}, function () {//2
        var data = db.getRst("demo_pjan", {SEX:"T", GEO:"NL"}, "TIME asec"); //3

        $("div#info").append("<h2>Total population in the Netherlands:</h2>");
        data.forEach(function(d) {$("div#info").append("<p>In " + d.TIME + ": " + d.OBS_VALUE + "</p>");}); //4
    });
});
//What's happening here?
//1: Create a table for the dataflow "demo_pjan".
//   Fix the dimensions "FREQ" and "AGE" so that we always fetch annual data and age aggregates.
//   Also fix the time period to always fetch data between 2000 and 2015.
//2: Fetch "demo_pjan" data for total, male, and female population of BeNeLux countries.
//3: Get record set that has 'total' population for Netherlands, ordered by ascending year.
//4: Make a list of the values that were found.
>>>>>>> 9489474946b71a8af81d53b14a85249261601733
